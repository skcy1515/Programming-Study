# 소스코드
고급 언어로 작성된 소스 코드가 저급 언어로 변환돼 컴퓨터에서 실행

- 고급 언어
	- 개발자가 이해하기 쉽게 만든 언어
- 저급 언어
	- 컴퓨터가 이해하고 실행하는 언어, 명령어들로 이루어져 있음

- 기계어: 0과 1로 이루어진 명령어로 구성된 저급 언어
- 어셈블리어: 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

### 컴파일 언어와 인터프리트 언어
- 컴파일 언어 -> 컴파일 -> 저급 언어
- 인터프리터 언어 -> 인터프리트 -> 저급 언어

- 컴파일 언어: 컴파일 언어로 작성된 소스 코드는 컴파일러에 의해 저급 언어로 변환되고 (이 과정을 컴파일이라고 함) 컴파일 결과로 저급 언어인 목적 코드가 생성된다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/6ca58cd6-4182-4d2d-8d6a-e29aeb29466f)

- 인터프리트 언어: 인터프리터에 의해 한 줄씩 실행, 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요 없음

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/eb8b1ca9-1395-4d39-a1a1-8c3cf007503c)

소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않지만, 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행한다.

# 명령어
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/94e2fca5-52d7-426e-a040-362b71816a68)

기계어, 어셈블리어도 명령어다, 명령어는 연산 코드와 오퍼랜드로 구성됨
- 연산 코드: 수행할 연산 
- 오퍼랜드: 연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치

```
mov  eax, 0 // 오퍼랜드가 둘
pop rbp // 오퍼랜드가 하나
ret // 오퍼랜드가 없는 경우
```

# 연산 코드
1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

### 데이터 전송
- move: 데이터를 옮겨라
- store: 메모리에 저장하라
- load (fetch): 메모리에서 CPU로 데이터를 가져와라
- push: 스택에 데이터를 저장하라
- pop: 스택의 최상단 데이터를 가져와라

### 산술/논리 연산
- add, subtract, multiply, divide: 덧셈, 뺄셈, 곱셈, 나눗셈,
- increment, decrement: 오퍼랜드에 1을 더하라, 1을 빼라
- and, or, not
- compare: 두 개의 숫자 또는 true / false 값을 비교하라

### 제어 흐름 변경
- jump: 특정 주소로 실행 순서를 옮겨라
- conditional jump: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- halt: 프로그램의 실행을 멈춰라
- call: 되돌아 올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- return: call을 호출할 때 저장했던 주소로 돌아가라

### 입출력 제어
- read(input): 특정 입출력 장치로부터 데이터를 읽어라
- write(output): 특정 입출력 장치로 데이터를 써라
- start io: 입출력 장치 시작
- test io: 입출력 장치의 상태 확인

# 명령어 주소 지정 방식
오퍼랜드 필드에 숫자나 문자와 같이 연산에 필요한 데이터보다는 메모리나 레지스터의 주소를 담는 경우가 많다.

명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도밖에 남지 않는다. 즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2⁶가지로 64개 밖에 되지 않는다.

하지만 여기서 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다. 예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정하면, 이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2¹⁶가지로 확 커진다.

이렇게 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소(effective address)`라고 한다. 그리고 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 `주소 지정 방식(address modes)`이라고 한다. 주소 지정 방식은 유효 주소를 찾는 방법이다.

주소 지정 방식은 아래와 같이 5가지가 있다.

- 즉시 주소 지정 방식
- 직접 주소 지정 방식
- 간접 주소 지정 방식
- 레지스터 주소 지정 방식
- 레지스터 간접 주소 지정 방식

### 즉시 주소 지정 방식
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/0d0d684b-2719-4790-9ff0-f42b37cc8f37)

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방법, 데이터의 크기가 작아질 수 있지만 데이터를 메모리나 레지스터로부터 찾는 과정이 없기에 빠름

### 직접 주소 지정 방식
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e15150fe-eb65-4e98-be2f-726a94f9f09f)

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식, 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들음

### 간접 주소 지정 방식
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/7fca7a37-1e2d-45e1-8c31-7b41ff392af6)

유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식, 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓지만 두 번의 메모리 접근이 필요하기에 느리다.

### 레지스터 주소 지정 방식
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/d2d66f43-7742-45c6-bcee-0c3890489647)

연산에 사용할 데이터가 저장된 레지스터 명시하는 방식, 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠르다.

메모리는 CPU 밖에 있고, 레지스터는 CPU 내부에 있다.따라서 CPU는 레지스터에 접근하는 속도가 훨씬 빠르다.
 
### 레지스터 간접 주소 지정 방식
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/d9c64c77-700f-495b-99c8-cd40800782c7)

연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법, 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이가 있다. 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠르다.

