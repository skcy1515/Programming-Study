# 메모리의 종류
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e475e09f-34c1-44ff-a82e-93d0bd657472)
- 레지스터: 가장 빠른 기억장소로 CPU 내에 존재, 컴퓨터 전원이 꺼지면 데이터가 사라지기 때문에 휘발성 메모리라고 불린다. 32bit와 64bit는 레지스터의 크기. CPU는 계산을 할 때 메인 메모리에 있는 값을 레지스터로 가져와 계산하고 계산 결과는 다시 메인 메모리에 저장시킨다.
- 캐시: 미리 가져온 데이터를 저장하는 곳 (레지스터와 메인 메모리의 중간 다리 역할) 캐시는 성능의 이유로 여러 개 둔다. 만약 CPU가 값을 요청해 레지스터로 값을 옮겨야 한다면 단계에 따라 가장 속도가 빠른 L1캐시를 보고 여기에 없다면 L2캐시를 확인해보고 여기도 없다면 메인 메모리에서 값을 가져온다.
- 메인 메모리: 실제 운영체제와 다른 프로세스들이 올라가는 공간. 전원이 공급되지 않으면 데이터가 지워지기 때문에 휘발성 메모리. 데이터를 저장하기보다는 실행중인 프로그램만 올림.
- 보조 저장 장치: 전원이 공급되지 않아도 데이터가 지워지지 않는 비휘발성 메모리

# 메모리와 주소
운영체제는 메모리를 관리하기 위해서 1바이트 크기로 구역을 나누고 숫자를 매긴다. 이 숫자는 주소라고 부른다. (1바이트, 8비트마다 주소를 가지고 있음)

32비트 CPU가 다룰 수 있는 메모리는 2^32로 4GB이다. (1기가 바이트 = 2^30 = 1,000,000,000) 64비트 CPU가 다룰 수 있는 메모리는 2^64로 거의 무한대에 가깝다. 64비트 CPU가 32비트 CPU보다 한번에 처리할 수 있는 양이 많기 때문에 속도가 빠르다.

### 물리주소와 논리주소
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/54dad4aa-e100-4995-9efc-78acaff85ee0)

메모리를 컴퓨터에 연결하면 0x0번지부터 시작하는 주소공간이 있는데 이를 `물리 주소 공간`이라고 한다. 이와 다르게 사용자 관점에서 바라본 주소공간은 `논리 주소 공간`이라고 부른다. 사용자는 물리 주소를 몰라도 논리 주소로 물리 주소에 접근할 수 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/380b0429-d91a-4441-a0ad-62f13334d2ec)

메모리에는 운영체제와 수 많은 프로세스가 올라오는데 운영체제를 위한 공간을 따로 마련해둔다. 만약 프로세스가 운영체제를 침범하면 컴퓨터가 위험해질 수 있기 때문에 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 경계 레지스터를 만들었다. 경계 레지스터는 CPU내에 존재하는 레지스터로 메모리 관리자가 사용자 프로세스가 경계 레지스터의 값을 벗어났는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킨다. 

### 절대주소와 상대주소
메모리에는 절대주소와 상대주소라는 개념이 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e3824987-633c-4a4c-8c2f-a9394345f238)

만약 사용자가 0x100번지 (상대 주소, 논리 주소)에 있는 데이터를 요청한다고 가정하자. CPU는 메모리 관리자에게 100번지에 있는 데이터를 가져오라고 하는데, 메모리 관리자는 CPU가 요청한 0x100번지와 재배치 레지스터에 있는 0x4000번지의 값을 더한 0x4100번지(절대 주소, 물리 주소)에 접근해서 데이터를 가져온다. 재배치 레지스터에는 프로그램의 시작 주소가 저장되어 있다. 메모리 관리자는 사용자가 메모리에 접근할 때마다 이렇게 계산한다.

메모리 관리자덕분에 모든 사용자 프로세스는 0x0번지부터 시작한다는 가정으로 편하게 프로그램을 만들 수 있고, 만약 시작영역이 바뀌더라도 재배치 레지스터만 변경해주면 되기 때문에 굉장히 유연하다.

# 메모리 할당 방식
- 가변 분할 방식: 프로세스의 크기에 따라 메모리를 나누는 방식
- 고정 분할 방식: 프로세스 크기와 상관없이 메모리를 정해진 크기로 나누는 방식

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/16e5a6ec-f771-4e04-a0a6-2456321d6833)

크기가 5MB인 프로세스 A가 있고 2MB인 프로세스 B와 1MB인 프로세스 C가 있다고 가정하자. 가변 분할 방식은 프로세스의 크기에 따라 메모리를 나누기 때문에 메모리에 프로세스 A를 위한 5MB를 확보하고 프로세스 B를 위한 2MB를 확보하고 프로세스 C를 위한 1MB를 확보한다. 한 프로세스가 메모리에 연속된 공간에 할당되기 때문에 `연속 메모리 할당`이라고 한다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/cbdec0c7-c9a3-4eed-9cb4-9acd963eb484)

고정 분할 방식은 프로세스의 크기에 상관없이 메모리를 정해진 크기로 나눈다. 메모리 크기를 2MB로 나눈다고 가정하면, 5MB가 필요한 프로세스 A는 2MB로 나눈 구역 세 개에 나눠서 할당된다. 1MB는 빈 공간으로 남는다. 프로세스 B는 2MB이기 때문에 크기가 정확히 맞고, 프로세스 C는 1MB이기 때문에 1MB는 빈 공간으로 남는다. 이 방식은 한 프로세스가 메모리에 분산되어 할당되기 때문에 `비연속 메모리 할당`이라고 한다.

가변 분할 방식의 장점은 메모리에 연속된 공간에 할당되기 때문에 더 크게 할당돼서 낭비되는 공간인 `내부 단편화`가 없다. 단점으로는 `외부 단편화`가 발생한다. 

고정 분할 방식의 장점은 구현이 간단하고 오버헤드가 적다는 것이다. 단점은 작은 프로세스도 큰 영역에 할당돼서 공간이 낭비되는 `내부 단편화`가 발생한다.

오늘날의 운영체제는 가변 분할 방식과 고정 분할 방식을 혼합하여 단점을 줄였다.

### 외부 단편화 
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e9fb91c7-aa63-4653-8634-9b16079f2cc2)

만약 두 개의 프로세스가 작업이 끝나 빈 공간이 50MB, 10MB가 생겼을 때 60MB의 프로세스를 할당할 수 있을 것 같지만 연속된 공간이 아니기 때문에 하지 못 한다. 이를 외부 단편화 문제라고 부른다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/f5f311d3-ebbf-42e4-9d06-eb233e01c6eb)

외부 단편화가 발생했을 때는 외부 단편화가 발생한 공간을 합쳐주는 조각모음을 하면 된다. 하지만 조각모음을 하려면 현재 메모리에서 실행되고 있는 프로세스들의 작업을 일시 중지해야하고 메모리 공간을 이동시키는 작업을 해야하기 때문에 오버헤드가 발생한다.

### 내부 단편화
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/9df294c0-2c56-45db-8173-e7d87aaeca6b)

메모리에 서로 다른 크기를 가지고 있는 여러 개의 프로세스가 올라오고, 이 예시에서는 20MB 크기로 메모리를 분할한다고 가정한다. 메모리가 부족하기 때문에 프로세스 A의 나머지 10MB는 스왑영역에 할당된다. 여기서 프로세스 C의 크기와 프로세스 D의 크기는 할당된 크기보다 작기 때문에 빈 공간이 발생한다. 이를 내부 단편화라고 부르는데, 이를 해결하는 방법은 없고 분할되는 크기를 조절해서 내부 단편화를 최소화한다.

### 버디 시스템
가변 분할 방식과 고정 분할 방식을 혼합한 방식, 버디 시스템은 2의 승수로 메모리를 분할해 메모리를 할당하는 방식이다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/2e6c90a5-6d89-4258-829e-3398c5eb52a7)

메모리 크기가 2^11인 2048B라고 가정하자. 크기가 500MB인 프로세스가 메모리 할당을 원한다. 그럼 먼저 2의 승수로 500B보다 작은 값을 만날 때 까지 나눈다. 세 번을 나누면 256B공간이 나오는데 여기엔 500B를 할당할 수 없으므로 이 보다 더 큰 구역인 512B 공간에 프로세스를 할당한다. 여기서도 내부 단편화가 발생하지만 12B밖에 발생하지 않는다. 

이 프로세스가 작업을 마치고 메모리에서 나가도 근접한 메모리 공간을 합치기 쉽다. 그 이유는 2의 승수로 동일하게 나눠서 반대로 조립만 하면 큰 공간이 만들어지기 때문에  조각 모음보다 훨씬 간단하다. 

버디 시스템의 장점은 가변 분할 방식처럼 프로세스의 크기에 따라 할당되는 메모리 크기가 달라지고 외부 단편화를 방지하기 위해 메모리 공간을 확보하는 것이 간단하다.
