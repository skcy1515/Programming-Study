# 메모리의 종류
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e475e09f-34c1-44ff-a82e-93d0bd657472)
- 레지스터: 가장 빠른 기억장소로 CPU 내에 존재, 컴퓨터 전원이 꺼지면 데이터가 사라지기 때문에 휘발성 메모리라고 불린다. 32bit와 64bit는 레지스터의 크기. CPU는 계산을 할 때 메인 메모리에 있는 값을 레지스터로 가져와 계산하고 계산 결과는 다시 메인 메모리에 저장시킨다.
- 캐시: 미리 가져온 데이터를 저장하는 곳 (레지스터와 메인 메모리의 중간 다리 역할) 캐시는 성능의 이유로 여러 개 둔다. 만약 CPU가 값을 요청해 레지스터로 값을 옮겨야 한다면 단계에 따라 가장 속도가 빠른 L1캐시를 보고 여기에 없다면 L2캐시를 확인해보고 여기도 없다면 메인 메모리에서 값을 가져온다.
- 메인 메모리: 실제 운영체제와 다른 프로세스들이 올라가는 공간. 전원이 공급되지 않으면 데이터가 지워지기 때문에 휘발성 메모리. 데이터를 저장하기보다는 실행중인 프로그램만 올림.
- 보조 저장 장치: 전원이 공급되지 않아도 데이터가 지워지지 않는 비휘발성 메모리

# 메모리와 주소
운영체제는 메모리를 관리하기 위해서 1바이트 크기로 구역을 나누고 숫자를 매긴다. 이 숫자는 주소라고 부른다. (1바이트, 8비트마다 주소를 가지고 있음)

32비트 CPU가 다룰 수 있는 메모리는 2^32로 4GB이다. (1기가 바이트 = 2^30 = 1,000,000,000) 64비트 CPU가 다룰 수 있는 메모리는 2^64로 거의 무한대에 가깝다. 64비트 CPU가 32비트 CPU보다 한번에 처리할 수 있는 양이 많기 때문에 속도가 빠르다.

### 물리주소와 논리주소
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/54dad4aa-e100-4995-9efc-78acaff85ee0)

메모리를 컴퓨터에 연결하면 0x0번지부터 시작하는 주소공간이 있는데 이를 `물리 주소 공간`이라고 한다. 이와 다르게 사용자 관점에서 바라본 주소공간은 `논리 주소 공간`이라고 부른다. 사용자는 물리 주소를 몰라도 논리 주소로 물리 주소에 접근할 수 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/380b0429-d91a-4441-a0ad-62f13334d2ec)

메모리에는 운영체제와 수 많은 프로세스가 올라오는데 운영체제를 위한 공간을 따로 마련해둔다. 만약 프로세스가 운영체제를 침범하면 컴퓨터가 위험해질 수 있기 때문에 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 경계 레지스터를 만들었다. 경계 레지스터는 CPU내에 존재하는 레지스터로 메모리 관리자가 사용자 프로세스가 경계 레지스터의 값을 벗어났는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킨다. 

### 절대주소와 상대주소
메모리에는 절대주소와 상대주소라는 개념이 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e3824987-633c-4a4c-8c2f-a9394345f238)

만약 사용자가 0x100번지 (상대 주소, 논리 주소)에 있는 데이터를 요청한다고 가정하자. CPU는 메모리 관리자에게 100번지에 있는 데이터를 가져오라고 하는데, 메모리 관리자는 CPU가 요청한 0x100번지와 재배치 레지스터에 있는 0x4000번지의 값을 더한 0x4100번지(절대 주소, 물리 주소)에 접근해서 데이터를 가져온다. 재배치 레지스터에는 프로그램의 시작 주소가 저장되어 있다. 메모리 관리자는 사용자가 메모리에 접근할 때마다 이렇게 계산한다.

메모리 관리자덕분에 모든 사용자 프로세스는 0x0번지부터 시작한다는 가정으로 편하게 프로그램을 만들 수 있고, 만약 시작영역이 바뀌더라도 재배치 레지스터만 변경해주면 되기 때문에 굉장히 유연하다.
