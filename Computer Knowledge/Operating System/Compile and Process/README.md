# 컴파일과 프로세스
- 컴파일 언어: 개발자가 만든 코드를 컴파일이라는 과정을 거쳐 0과 1로 된 기계어로 실행파일을 만듦
- 인터프리트 언어: 개발자가 만든 코드를 실행 시 한 줄씩 해석해 실행함

### 프로세스의 메모리 구조
- 코드영역: 실행해야 할 코드가 들어있는 영역
- 데이터영역: 전역변수, 배열이 들어있는 영역
- 힙영역, 스택영역: 프로세스가 실행될 때 할당되는 메모리로 스택에는 지역변수와 함수 관련 값들이 들어가고 힙은 실행중에 메모리 공간을 할당할 수 있는 유동적인 공간이다.

### 컴파일 과정
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/071ebafd-2c4b-4f99-9e4f-a0abc169852e)

개발자가 작성한 코드는 컴파일러를 거쳐서 실행파일이 된다.
1. 개발자가 코드를 작성하고 test.c라는 파일로 저장

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/d9f1a8e5-ea80-44c4-b11d-df7178303c20)

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/dc737551-4eac-4508-885c-5a5b7d117b7d)

2. 전처리기는 test.c 파일을 훑어보고 전처리 구문을 처리해준다. 전처리 구문은 #으로 시작하는데 여기서는 #include와 #define이 있다. 전처리기를 거치면 2번 줄의 #include를 통해 stdio.h의 내용이 들어오게 되고 4번 줄에서 선언한 매크로 MY_NUMBER 값은 전부 100으 치환되며, 코드에 있는 모든 주석은 제거된다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e59eb0b9-643b-4144-a0d7-19c51159eaaf)

3. 전처리기를 거친 test.i는 컴파일러가 처리, 컴파일러는 C언어로 작성된 이 파일을 기계어에 가까운 어셈블리어로 변환시킨다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/7010dd09-d730-4a40-ad98-fd5b30a4a312)

4. 어셈블러를 통해 test.s 파일을 오브젝트 파일로 변환시킨다. 오브젝트 파일은 0과 1로 된 기계어로 구성되어 있기 때문에 텍스트 에디터에서 열게 되면 이렇게 글씨가 깨지게 된다. 이 오브젝트 파일에는 코드 영역과 데이터 영역이 나뉘어져 있다. 이 오브젝트 파일이 실행파일이 되기 위해서는 링커를 거쳐줘야 한다.
5. 링커는 모든 오브젝트 파일을 하나의 코드 영역과 데이터 영역으로 묶는다. 그리고 실제로 실행될 주소를 매핑시켜준다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/f89d7174-70ed-45e1-b702-aaefd876f856)

6. 완벽한 상태의 코드 영역과 데이터 영역으로 구성된 실행파일인 exe 파일이 생긴다. 사용자가 이 파일을 실행하면 운영체제가 프로세스를 만든다. 운영체제는 exe파일에 있는 코드 영역과 데이터 영역을 가져와 프로세스의 코드 영역과 데이터 영역에 넣어주고 빈 상태의 스택과 힙을 할당한다. 그리고 PCB를 만들어 관리가 가능하도록 만들고 프로그램 카운터 즉, 다음 실행할 명령어의 주소를 생성한 프로세스의 코드 영역의 첫 번째 주소로 설정한다. 그러면 운영체제의 스케줄링에 따라서 프로세스가 실행되다가 작업을 마친다.

# 중간 정리
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/53c65f04-e66c-4810-8b33-4b8883eb23c5)

오늘날 컴퓨터는 폰 노이만 구조를 하고 있고 폰 노이만 구조의 필수 장치는 CPU와 메모리다. 그리고 컴퓨터의 성능이나 사용자의 편의성을 위한 보조장치가 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/64a2652e-004a-4409-ae1f-7f3db950359d)

컴퓨터가 부팅되면 보조장치인 하드디스크에 저장되어 있는 운영체제가 메모리에 올라오게 되고 모든 프로그램은 운영체제에 의해서 관리된다. 프로그램도 하드디스크에 저장되어 있는데 용자가 이 프로그램을 실행하면 메모리에 올라간다. 메모리에 올라간 프로그램을 프로세스라 부르고 프로세스는 자기를 실행시켜 줄 CPU를 기다린다. 하지만 CPU를 원하는 프로세스들이 많기 때문에 운영체제가 중간에서 공평하게 CPU를 할당해준다. 운영체제가 중간에서 CPU를 할당해주는 것을 CPU 스케줄링이라고 부른다.

CPU 스케줄링은 공평함과 성능문제 때문에 프로세스들에게 일정 시간, 즉 타임 슬라이스만큼 CPU를 할당하기로 했고 이 때문에 공유된 자원에서 문제가 발생한다는 것을 알았다. 이를 동기화 문제라고 부르고 이를 해결하기 위한 방법인 세마포어와 모니터가 알아보았다.

동기화 문제를 해결하기 위해 공유 자원을 한 프로세스가 점유하게 만들었는데 교착상태라는 것이 발생했다. 그래서 교착상태를 해결하는 방법을 알아보았다.
