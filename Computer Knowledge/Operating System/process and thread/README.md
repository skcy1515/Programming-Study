# 프로세스
- 프로그램: 저장장치에 저장된 명령문의 집합체, 애플리케이션이나 앱이라고도 불린다.
- 프로세스: 실행중인 프로그램, 프로그램이 메모리에 올라갔을 때 실행중인 프로그램이라고 할 후 있다.

프로그램은 수동적인 존재지만 프로세스는 메모리도 사용하고 운영체제의 CPU 스케줄링 알고리즘에 의해 CPU도 사용하고 필요에 따라 입력과 출력을 하기 때문에 능동적인 존재이다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/2dead039-75ad-4d78-9400-ad1aba378f17)

프로세스는 4개의 영역으로 나뉜다.
- code 영역: 자신을 실행하는 코드가 저장됨
- data 영역: 전역 변수와 Static 변수가 저장됨
- stack 영역: 지역 변수와 함수 호출시 필요한 정보들이 저장됨
- heap 영역: 프로그래머가 동적으로 메모리를 할당하는 데에 쓰임

### 코드가 메모리에 올라가서 프로세스가 되는 과정
```
#include <stdio.h>

void main()
{
	int num1 = 5;
	int num2 = 7;
	int result = num1 + num2;
}
```
1. 컴파일을 해야 실행이 가능하므로 컴파일을 해줘야 한다.
2. 전처리기를 거쳐 매크로로 정의한 숫자를 치환하고 필요한 파일들을 불러옴
3. 컴파일러가 컴파일을 하여 고수준인 C언어를 저수준인 어셈블리어로 바꿔줌
4. 어셈블러가 어셈블리어를 기계어로 바꿔줌
5. 링커가 링킹(여러 가지 라이브러리나 다른 소스코드를 연결)을 함
6. exe 프로그램으로 만들어짐
7. exe를 실행시키면 메모리에 올라가게 되고 이렇게 올라간 프로그램은 프로세스가 된다.

### 프로세스 실행 과정 (CPU 관점)

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/6f55e716-d927-43db-9b01-06e253d79990)

1. cpu내의 저장 장치가 숫자 5와 7을 메모리에 저장시킴
2. 메모리에 저장된 값을 edx, eax 레지스터로 가져옴
3. 제어 장치가 레지스터에 저장된 5와 7을 가지고 더하라는 명령을 하면 ALU가 두 숫자를 더하고 그 결과는 eax 레지스터에 저장함
4. 다시 제어 장치가 eax 레지스터에 저장된 12를 가져와서 메모리에 저장시킴


# 멀티프로그래밍과 멀티프로세싱
- 유니프로그래밍: 메모리에 오직 하나의 프로세스가 올라온 것
- 멀티프로그래밍: 메모리에 여러 개의 프로세스가 올라온 것
- 멀티프로세싱: CPU가 여러 개의 프로세스를 처리하는 것

오늘날 OS는 멀티프로그래밍과 멀티프로세싱 두 개가 공존함

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/74e2bfde-2bed-4875-a0a8-bb96f71cec45)

# PCB (Process Control Block)
운영체제는 여러 개의 프로세스를 전부 다 관리하고 공평하게 실행시켜야 한다. 프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 `PCB` 를 만들고 저장함

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/4a0e28d9-ad12-4b99-8f01-905cdc9fd9e3)

PCB들은 연결리스트라는 자료구조로 저장된다. 운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거한다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/a83a91a6-f71b-46bf-9d45-f709363056f2)

### PCB의 구조
- 포인터: 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터 등이 있고 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.
- 프로세스 상태: 현재 프로세스의 다섯가지 상태 (생성, 준비, 실행, 대기, 완료)를 나타냄
- 프로세스 ID: 프로세스를 식별하기 위한 숫자 저장
- 프로그램 카운터: 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장. 오늘날 OS는 시분할 처리로 여러 프로세스를 짧은 시간동안 번갈아 실행, 어떤 프로세스가 실행되다가 다른 프로세스에게 CPU를 뺏기고 다시 실행될 때 원래 실행하던 명령어가 실행되어야 하므로 프로그램 카운터는 꼭 필요하다.
- 레지스터 정보: 프로세스가 실행될 때 사용했던 레지스터 정보 저장, 프로그램 카운터와 같이 이전에 사용하던 값을 복구하기 위한 용도
- 메모리 관련 정보: 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계레지스터 값 저장
- CPU 스케줄링 정보: CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간 등이 저장됨

# 프로세스 상태
시분할 시스템을 사용하는 운영체제는 여러 개의 프로세스를 돌아가면서 실행한다. CPU가 여러 개의 프로세스를 동시에 실행하는 것이 아닌 한 순간에 하나의 프로세스밖에 처리하지 못 하지만, 속도가 매우 빨라서 동시에 실행되는 것처럼 보인다.

프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.
- 생성 상태: PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태
- 준비 상태: CPU를 사용하기 위해 기다리고 있는 상태, 준비 상태에 있는 프로세스는 CPU 스케줄러에 의해 CPU가 할당됨. 대부분의 프로세스는 이 준비상태에 있음
- 실행 상태: 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태, 실행상태에 있는 프로세스의 수는 CPU의 개수만큼, CPU 스케줄러는 부여된 시간을 초과하면 할당된 CPU를 강제로 빼앗아 프로세스는 다시 준비상태로 돌아감
- 대기 상태: 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태
- 완료 상태: 프로세스가 종료된 상태

# 컨텍스트 스위칭
컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해
실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업이다.

컨텍스트 스위칭이 일어날 때 PCB의 내용이 변경된다. PCB의 변경되는 값들로는 프로세스 상태, 프로그램 카윤터, 레지스터 정보, 메모리 관련 정보들이 변경된다. 실행중인 프로세스의 작업 내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅된다. 

컨텍스트 스위칭은 CPU 점유시간이 다 되거나 입출력 요청이 있거나 다른 종류의 인터럽트가 있을 때 발생

# 프로세스 생성과 종료
1. exe 파일 실행
2. 운영체제는 해당 프로그램의 코드 영역과 데이터 영역을 메모리에 로드하고
빈 스택과 빈 힙을 만들어 공간 확보
3. 프로세스를 관리하기 위한 PCB를 만들어서 값을 초기화함

이 과정은 운영체제가 부팅되고 0번 프로세스가 생성될 때의 과정, 나머지 프로세스들은 0번 프로세스를 복사해서 쓰게됨

0번 프로세스를 복사해서 생성되는 프로세스는 자식 프로세스라고 함. 자식 프로세스는 부모 프로세스의 코드 영역, 데이터 영역, 스택 영역과 PCB의 내용을 전부 복사

fork() 함수로 프로세스를 복사하고 exec() 함수를 실행시키면 부모를 복사한 자식 프로세스의 코드와 데이터 영역을 원하는 값으로 덮어쓰게 됨

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/ce4143d2-01e3-4c9a-a1f5-399ea66ed9a1)

이 두개의 프로세스는 CPU 스케줄링에 따라 실행됨
- exit(): 자식 프로세스가 부모 프로세스에게 정상 종료를 알리는 함수
- wait(NULL): 자식 프로세스가 exit() 함수를 실행시킬 때까지 대기

만약 부모 프로세스가 자식 프로세스보다 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 exit 신호를 주지 못하면 메모리에 계속 살아있는 좀비 프로세스가 만들어진다.

# 쓰레드
프로그램 실행의 단위, 프로세스 내에 존재하는 것으로 1개 이상이 있을 수 있다.

한 프로세스 내에 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공유, 스택은 공유하지 않고 쓰레드마다 하나씩 가진다. 쓰레드 마다 구별하기 위해 쓰레드 ID를 부여하고 이 쓰레드들을 관리하기 위한 TCB (Thread Control Block)이 생긴다. 

웹 브라우저를 실행하면 프로세스 하나가 생성되고 쓰레드도 하나 생성됨 여기서 탭이 늘어나면 프로세스가 아닌 쓰레드를 계속 생성한다 (반면 크롬은 프로세스를 생성)

안정성 측면에서는 프로세스 방식이 쓰레드 방식보다 더 우수 (프로세스는 서로 독립적이라 하나의 프로세스에 문제가 일어나도 다른 프로세스들이 영향X, 반대로 쓰레드는 프로세스가 문제가 일어나면 쓰레드들도 문제가 일어남)

속도와 자원은 쓰레드 방식이 우수 (프로세스 간에 통신을 하려면 IPC를 이용해야 해서 오버헤드가 크고 속도가 느림 반면 쓰레드는 한 프로세스 내에서 스택 영역을 제외한 영역을 모두 공유하기 때문에 오버헤드가 굉장히 작음)
