# OS(운영체제)란?
컴퓨터 시스템의 핵심 소프트웨어로, 컴퓨터 하드웨어와 응용 프로그램 간의 상호작용을 관리하고 제어하는 역할을 하는 인터페이스이다.

(인터페이스 : 서로 다른 두 개의 시스템 사이에서 정보나 신호를 주고 받는 접점이나 경계를 의미)

# 커널이란?
커널은 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당하는 운영체제의 핵심 부분이다.

기본적으로 프로그램이 실행되기 위해서는 주기억장치에 적재된 상태여야 하는데, 운영체제 역시 프로그램이기 때문에 메인 메모리에 적재가 되어야 하나, 운영체제의 크기가 너무 커서 전체를 다 메인 메모리에 올리게 된다면 비효율적이다. (메모리 공간의 낭비)

따라서 커널(kernel)이라고 하는 항상 필요한 운영체제의 핵심 부분만을 메인 메모리에 적재하여 운영체제를 사용하게끔 하는데 즉, 커널은 메모리에 상주하는 운영체제의 핵심 부분이라고 할 수 있다.

# 메모리의 구조를 영역에 따라서 설명하면? 
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/c7530da6-eb0f-4f02-a1f2-034b09a98cc0)

- 코드 영역(텍스트 영역) : 실행할 프로그램의 코드가 저장되는 영역으로, CPU는 해당 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.
- 데이터 영역(static 영역) : 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 시작하는 동시에 할당되며, 프로그램이 종료되면 소멸한다.
- 힙 영역 (Heap) : 사용자가 직접 관리하는 영역이며 메모리 공간이 동적으로 할당 및 헤제된다. 동적으로 할당되므로 new로 생성한 object(객체)가 많아질 수록 힙 영역의 크기가 늘어나게 된다.
- 스택 영역 (Stack) : 함수의 호출에 따른 지역변수와 매개변수가 저장되는 영역으로, 컴파일 시 크기가 결정된다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 소멸한다.

# 메모리의 힙 영역과 스택 영역의 차이는?
- 저장하는 데이터
  - 스택: 지역변수, 매개변수
  - 힙: 동적으로 생성된 변수, 객체 (new 연산자)
- 크기
  - 스택: 크기가 제한되어 있다, 컴파일시에 크기가 결정된다.
  - 힙: 크기가 동적이다 (제한되어 있지 않다), 런타임시에 크기가 결정된다.
- 할당방식
  - 스택: 정적 할당 방식을 사용한다(속도가 빠르다). 함수 호출 시 지역 변수와 함수의 매개변수가 스택에 자동으로 할당되고, 함수가 종료될 때 이들이 자동으로 해제된다. 이러한 자동 할당 및 해제는 후입선출(LIFO) 방식으로 이루어진다.
  - 힙: 힙은 동적 할당 방식을 사용한다(속도가 느리다). 프로그램 실행 중에 필요한 메모리를 동적으로 할당하고 해제할 수 있다. 이는 프로그래머가 직접 할당 및 해제를 관리해야 한다는 점에서 스택과 다르다.

# 메모리의 힙 영역을 크게 잡으면 어떤 문제가 발생하나?
힙 영역은 스택 영역과 다르게 직접 생성된 변수를 제거를 통해 메모리 관리가 필요하다. 만약 메모리의 힙 영역이 너무 크다면, 넓은 힙 영역에 존재하는 동적 변수에 대해 참조 여부를 확인해야 하기 때문에 Garbage Collect의 수행시간이 너무 길어지게 된다.

따라서 Java의 JVM에서도 처음부터 힙 영역을 크게 잡지 않고, Heap 영역이 꽉 찼을 때 GC 진행 후 Heap 영역을 확장하게 된다.

# 프로세스와 쓰레드가 뭐고, 그 둘의 차이점은?
- 프로세스
  - 메인 메모리(주기억장치)에 적재되어 실행되는 프로그램을 의미한다.
  - PCB, code, data, heap, stack 영역을 갖습니다.
  - 프로세스별 각각의 영역을 갖기 때문에 별다른 동기화 작업이 필요하지 않다.
  - 프로세스별 각각의 영역을 갖기 때문에 context switching 비용이 크다.
  - 프로세스 쓰레드보다 무겁기 때문에 생성 시간이 더 길다.
  - 한 프로세스에서 오류가 생기더라도 다른 프로세스에 영향을 주지 않는다.

- 쓰레드
  - 한 프로세스 내의 실행 단위, 실행의 흐름을 의미한다. 한 프로세스내에 여러 개가 존재할 수 있다.
  - stack 영역만 별도로 갖고, 나머지 영역(code, data, heap)에 대해서는 해당 쓰레드를 포함한 프로세스의 자원을 공유한다.
  - stack 영역 외부의 공유 자원에 대해 접근 시 동기화 작업이 필요하다.
  - stack 영역 외부를 공유하므로 컨텍스트 스위칭 비용이 적다.
  - 쓰레드는 프로세스보다 가볍기 때문에 생성 시간이 더 짧다.
  - 한 쓰레드에서 오류가 생기면, 나머지 프로세스 내의 쓰레드에 영향을 줄 수 있다.

# 컨텍스트 스위칭이란?
컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업이다. 컨텍스트 스위칭은 여러 프로세스/스레드를 동시에 실행시키기 위해 필요하다.

# 프로세스 제어 블록(PCB란)?
프로세스 제어 블록(PCB)은 운영체제가 프로세스를 관리하기 위한 정보를 포함하는 연결리스트 자료 구조이다. 

프로세스는 수행할 차례가 되면, CPU를 할당받아 작업을 처리한다. 작업을 처리하던 도중 프로세스의 시간이 모두 경과되거나 인터럽트가 발생하는 등의 프로세스 전환이 발생하면, 진행하던 작업을 저장하고 CPU 를 반환한다. 이 때, 수행하던 프로세스 관련 데이터들을 PCB 에 저장한다. 그리고 다시 프로세스의 수행 차례가 와서 CPU 를 할당받게 되면, PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다. 이렇게 사용하던 프로세스의 데이터를 PCB에 저장하고, 실행할 프로세스의 데이터를 PCB에서 불러오는 과정을 컨텍스트 스위칭 이라고 한다.

PCB 구조

- 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

# 멀티 쓰레드와 멀티 프로세스를 비교하면?
- 멀티 쓰레드: 하나의 프로세스를 여러 개의 쓰레드로 구성해 자원을 공유하면서 작업을 수행하는 것을 의미한다. 멀티 프로세스보다 적은 메모리 공간을 차지하고, 컨텍스트 스위칭이 빠른 장점이 있지만, 오류로 인해 하나의 쓰레드가 종료되면 전체 쓰레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다.
- 멀티 프로세스: 하나의 프로그램을 여러개의 프로세스로 구성해 프로세스가 병렬적으로 작업을 수행하는 것이다. 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않지만, 멀티 쓰레드보다 많은 메모리 공간을 차지합니다.

멀티 쓰레드를 더 많이 쓰는 이유는 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이고, 컨텍스트 스위칭 시, Stack 영역만 초기화하면 되기 때문에 더 빠르다. 또한 프로세스 생성시 자원 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있는 장점도 있다.

# 쓰레드가 독립적으로 할당하는 2가지
- 스택 영역: 프로세스 내의 독립적인 실행 흐름을 만들기 위해 쓰레드마다 스택 영역을 갖는다.
- PC Register: PC Register 값은, 쓰레드가 명령어를 어디까지 수행했는 지를 나타낸다. 쓰레드는 CPU를 할당받았다가, 스케줄러에 의해서 선점당해 컨텍스트 스위칭이 일어난다. 따라서 다시 해당 쓰레드가 실행될 때 어디까지 실행이 되었는지 알아야 하므로 독립적으로 PC Register 값을 갖게 된다.

#  경쟁 상태와 임계 영역이 무엇이고, 경쟁상태를 막기 위해 어떤 방법을 사용하는지?
두 개 이상의 쓰레드가 공유자원에 대해 접근하려고 서로 경쟁하는 것을 경쟁상태라고 한다. 이 공유자원이 존재하는 구간으로 경쟁상태가 일어날 수 있는 영역을 임계영역 이라고 한다.

이러한 임계영역에 대한 경쟁상태를 제거하기 위해서 한 공유자원에 대해서 한 쓰레드에만 접근을 허락하도록 하는 상호배제 매커니즘를 사용한다.
- 임계영역엔 동시에 하나의 프로세스만 접근한다.
- 여러 요청에도 하나의 프로세스의 접근만 허용한다.
- 임계구역에 들어간 프로세스는 빠르게 나와야한다.

# 교착상태란? 
DeadLock(교착상태)는, 두 개 이상의 프로세스나 쓰레드가 서로 자원을 기다리면서 무한히 대기하는 상태를 의미한다.

DeadLock이 발생하기 위한 조건은 4가지가 있습니다.
- 상호 배제 (Mutual Exclusion): 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
- 점유 대기 (Hold and Wait): 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
- 비선점 (Non-preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
- 순환 대기 (Circular Wait): 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.
 
교착상태를 해결하는 방법

- 예방(Prevention): 교착 상태 조건 중 하나를 제거함으로 데드락이 발생하지 않도록 예방하는 방식, 자원 낭비가 심하다.
- 회피(Avoidance): 데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식, 은행원 알고리즘
  - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘  
  - 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
  - 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
  - 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.

# '식사하는 철학자 문제'에서, DeadLock이 어떨 때 발생하는지 설명하고, 이를 해결하기 위한 방법은?
모든 철학자가 방에 입장한 후, 각자의 왼쪽포크를 5명이 모두 드는 경우에 DeadLock이 발생한다.

- 5명 모두 자신의 왼쪽 포크를 들고 있으므로 '점유대기'
- 남이 포크를 뺏어주지 않음 '비선점'
- 서로 오른쪽 포크를 놓기만을 기다림 '환형대기'
- 각 포크에 대해 한 사람만 들 수 있음 '상호배제'

이 문제를 해결하기 위해서, 카운팅 세마포어를 사용한다.

방에 대한 입장 정원을 카운팅 세마포어로 설계해, 최대 4명만 들어온다면 방 안의 모든 사람들이 왼쪽 포크를 든다 하더라도 DeadLock이 일어나지 않는다.

# 세마포어란?
세마포어(Semaphore)는 프로세스나 스레드 간의 동기화와 상호 배제를 위해 사용되는 동기화 기법 중 하나이다. 세마포어는 정수형 변수로, 주로 임계 영역(critical section)에 대한 접근을 조절하는 데 사용되며, 1개의 공유되는 자원에 제한된 개수의 프로세스(Process), 또는 스레드(Thread)만 접근할 수 있도록 한다.

# Multilevel Feedback Queue(다중 레벨 피드백 큐)란?
프로세스를 여러 개의 우선순위 레벨로 분류하고, 각 레벨에 대한 큐를 사용하여 처리하는 스케줄링 기법이다. 우선순위가 높으면 타임 슬라이스가 작고 우선순위가 낮을 수록 타임 슬라이스 크기가 커진다. 우선순위가 높은 큐일수록 처리해야 할 작업들이 적다. 

만약 프로세스를 처리 중 타임 슬라이스 크기를 오버해서 강제로 CPU를 뺏긴다면 그 프로세스는 원래 있던 큐보다 우선순위가 더 낮은 큐로 이동 그러면 다음 번에 실행될 때는 타임 슬라이스가 조금 더 커지게 되고 여기서도 부족하면 다음엔 더 큰 타임 슬라이스를 할당받게 된다.

# 동시성과 병렬성의 차이는?
동시성은 멀티 프로그래밍 (Multi-Programming)에서 나온 개념으로, 주기억장치에 여러 프로세스를 적재해서 컨텍스트 스위칭을 통해 동시에 실행되는 것 처럼 보이게 하는 것을 의미한다. 실제로는 동시에 실행되는 것이 아니라, 번갈아 실행하는 것이다. 싱글 코어에서 멀티스레드를 동작시키기 위한 방식이다.

병렬성은 멀티 프로세싱 (Multi-Processing)에서 나온 개념으로, 실제로 동시에 여러 프로세스를 병렬적으로 실행하는 방식이다. 병렬적으로 실행하기 위해서는 CPU가 멀티코어여야 한다. 

# 인터럽트란?
Interrupt(인터럽트)는 프로그램을 실행하고 있는 도중에 입출력 요청, 예외 상황을 처리해야 할 때 그리고 운영체제가 준 시간을 다 사용하여 다른 프로세스로 전환될 때 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 의미한다.

# 페이징과 세그멘테이션이란?
- 페이징 : 프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리해서 메인 메모리에 불연속적으로 저장하는 방식입니다. 만약 프로세스가 13MB이고 페이지가 4MB라면, 한 페이지는 1MB가 됩니다. 프레임은 무조건 4MB로 분리했으므로 3MB의 '내부단편화'가 발생할 수 있습니다. (연속 할당 방식보다는 적게 발생합니다.)

세그멘테이션 : 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다. 주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다. 세그멘테이션 역시 '외부 단편화'가 발생합니다. 


# 내부 단편화와 외부 단편화란?
내부 단편화는 고정길이 할당 / 페이지에서 나타나는 것으로, 물리메모리를 고정적인 길이의 파트로 잘랐을 때, 해당 파트의 길이보다 더 작은 크기의 조각이 들어가게 되어 생기는 여백을 의미합니다.

내부 단편화를 해결하는 방법은 없고 분할되는 크기를 조절해서 내부 단편화를 최소화한다.

외부 단편화는 가변길이 할당 / 세그멘테이션에서 나타나는 것으로, 메모리 할당과 해제로 인해 사용 가능한 메모리 공간이 작은 조각들로 나뉘어, 충분한 연속된 공간이 없어서 메모리를 할당하지 못하는 상태를 말한다.

외부 단편화가 발생했을 때는 외부 단편화가 발생한 공간을 합쳐주는 조각모음을 하면 된다. 하지만 조각모음을 하려면 현재 메모리에서 실행되고 있는 프로세스들의 작업을 일시 중지해야하고 메모리 공간을 이동시키는 작업을 해야하기 때문에 오버헤드가 발생한다.

# 가상 메모리란?
가상 메모리는 컴퓨터 시스템에서 사용되는 주 기억장치(RAM)의 일부를 하드 디스크나 SSD와 같은 보조 기억장치로 확장하는 기술이다. 이를 통해 물리적인 주 기억장치의 용량 한계를 극복하고 더 큰 프로그램과 데이터를 다룰 수 있게 된다.

가상메모리 시스템은 물리 메모리 내용의 일부를 하드 디스크에 있는 스왑 영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시키기 때문에 운영체제와 프로세스들을 전부 실행시킬 수 있다. 
