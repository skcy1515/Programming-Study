# CPU 스케줄링
프로그램을 실행시키면 메모리에 프로세스가 생성되고 각 프로세스에는 1개 이상의 쓰레드가 있다. 프로세스들은 CPU를 차지하기 위해 운영체제의 명령을 기다린다.

운영체제는 모든 프로세스에게 CPU를 할당/해제 하는데 이를 CPU 스케줄링이라고 한다.

CPU 스케줄링에서 스케줄러(운영체제)가 고려해야 할 사항은
1. 어떤 프로세스에게 CPU 리소스를 줘야하는가
2. CPU를 할당받은 프로세스가 얼마의 시간동안 CPU를 사용해야 하는가

CPU를 할당받아 실행하는 작업을 CPU Burst라고 부르고, 입출력 작업을 I/O Burst라고 부른다.

# 다중큐
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/bbb570f5-81b7-469d-9b8a-a93ed90491a2)

여기서 프로세스가 대기하고 있는 준비 상태와 대기 상태는 `큐`라는 자료구조로 관리된다 (FIFO, 먼저 들어온 것을 먼저 처리)

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/c010c5dd-ab47-4bdd-ba91-84c16840e2e5)

프로세스가 실행 상태에서 준비 상태로 돌아갈 때 운영체제는 해당 프로세스의 우선순위를 보고 그에 맞는 `준비 큐`에 넣는다. 

CPU 스케줄러는 `준비상태의 다중큐`에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킨다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/2d7f31c2-1ecf-4a9d-89aa-4d92143329f8)

프로세스가 실행 상태에서 I/O 요청을 받아 대기상태로 오게 되면 I/O 작업 종류에 따라서 분류된 큐에 들어가게 된다. 하드 디스크 작업은 HDD큐에 들어가고 하드 디스크 작업이 완료되어 인터럽트가 발생하면 HDD 큐를 다시 꺼내간다.

정리하자면 프로세스에 담겨 있는 PCB는 준비 상태의 다중큐에 들어가서 실행되기를 기다리고 있고 CPU스케줄러에 의해 실행상태로 전환된다. 이 때 CPU스케줄러는 준비 상태의 다중큐를 참조해서 어떤 프로세스를 실행시킬지 결정한다. I/O 작업도 비슷하다.

# 스케줄링 목표
- 리소스 사용률: CPU 사용률을 높이는 것을 목표로 할 수도 있고 I/O 디바이스의 사용률을 높이는 것을 목표로 할 수도 있다.
- 오버헤드 최소화: 스케줄링을 하기 위한 계산이 너무 복잡하거나 컨텍스트 스위칭을 너무 자주하는 등의 오버헤드를 최소화하는 것을 목표로 한다. (오버헤드: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리)
- 공평성: 모든 프로세스에게 공평하게 CPU가 할당되어야 한다. 공평의 의미는 시스템에 있는 프로세스의 중요도에 따라 달라질 수 있다.
- 처리량: 같은 시간내에 더 많은 처리를 할 수 있는 방법을 목표로 한다.
- 대기시간: 작업을 요청하고 실제 작업이 이루어지기 전까지 대기하는 시간이 짧은 것을 목표로 한다.
- 응답시간: 응답시간이 짧은 것을 목표로 한다.

목표들을 모두 최고의 수준으로 유지하기는 힘들기 때문에 사용자가 요구하는 시스템에 따라서 목표를 다르게 설정한다. (ex 터치스크린과 같이 사용자에게 빠른 응답이 필요한 경우에는 응답 시간이 짧도록 초점을 맞추고 과학 계산같은 경우는 처리량이 높도록 초점을 맞춘다.)

특별한 목적이 없다면 어느 한쪽에 치우치지 않도록 밸런스를 유지하는 것이 중요하다.

# FIFO
FIFO(First In First Out)는 먼저 들어온 작업이 먼저 나간다는 뜻으로 스케줄링 큐에 들어온 순서대로 CPU를 할당받는 방식이다.
- 장점: 단순하고 직관적
- 단점: 한 프로세스가 완전히 끝나야 다음 프로세스가 시작됨

스케줄링의 성능은 평균 대기 시간으로 평가하는데 FIFO 알고리즘은 프로세스의 Burst Time에 따라 성능의 차이가 심하게 나기 때문에 현대 운영체제에서 잘 쓰이지 않고 일괄처리시스템에 사용된다.

# SJF(Shortest Job First)
FIFO 알고리즘에서 Burst Time이 짧은게 먼저 실행되면 평균 대기 시간이 짧다. 이를 통해 짧은 작업을 먼저 실행하는 알고리즘을 만들기로 했다. 이를 SJF 알고리즘이라고 한다.

문제
- 어떤 프로세스가 얼마나 실행될지 예측하기 힘듦
- Burst Time이 긴 프로세스는 아주 오랫동안 실행되지 않을 수 있음

이러한 문제점 때문에 SJF 알고리즘은 사용되지 않는다.
