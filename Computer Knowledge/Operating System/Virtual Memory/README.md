# 가상 메모리
가상 메모리는 컴퓨터 시스템에서 사용되는 주 기억장치(RAM)의 일부를 하드 디스크나 SSD와 같은 보조 기억장치로 확장하는 기술이다. 이를 통해 물리적인 주 기억장치의 용량 한계를 극복하고 더 큰 프로그램과 데이터를 다룰 수 있게 된다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/13cdecf4-00fe-4cdc-a781-00c6d563b40b)

프로세스는 운영체제 영역이 어디있는지, 물리 메모리 크기가 얼마나 큰지 몰라도 된다. 프로세스는 메모리 관리자를 통해서 메모리에 접근한다. 프로세스 입장에서는 물리 메모리에 직접 접근할 일이 없고, 메모리 관리자에게 요청만 하면 된다. 메모리 관리자는 프로세스가 요청하면 그에 맞는 물리 메모리로 연결시켜준다. 가상 메모리는 프로그래머가 물리적 메모리의 세부 사항을 고려하지 않고도 더 큰 프로그램을 작성하고 실행할 수 있게 해준다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/e9f98b8d-55d4-47b3-be08-2b81084d74f1)

가상 메모리의 크기는 CPU의 비트수와 물리 메모리의 크기로 결정된다. 32bit CPU의 경우 최대 메모리 크기가 4GB인데 운영체제를 포함한 많은 프로세스들은 어떻게 실행시킬까? 가상메모리 시스템은 물리 메모리 내용의 일부를 하드 디스크에 있는 스왑 영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시키기 때문에 운영체제와 프로세스들을 전부 실행시킬 수 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/b0c239b0-1343-49ce-9f2a-3800806ccf6c)

메모리 관리자는 물리 메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상 주소를 물리 주소로 변환하는데 이것을 `동적주소변환(DAT)`라고 부른다. 동적 주소 변환을 거치면 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/101437e3-941a-46ef-935f-3cac78f6c599)

가상메모리 시스템에서 가상주소는 메모리나 스왑영역 한 곳 중에 위치한다. 메모리 관리자는 가상주소와 물리주소를 일대일 매핑 테이블로 관리한다.

# 세그멘테이션(배치정책)
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/d4a08180-788e-4251-80ec-64a30553578d)

가변분할 방식을 이용하는 세그멘테이션 기법을 알아보겠다. 세그멘테이션에서 프로그램은 함수나 모듈등으로 세그먼트를 구성한다. 프로그램(사용자) 입장에서 메모리를 살펴보면 메인 코드가 있는 세그먼트, 전역 데이터들이 있는 세그먼트, 힙영역이 있는 세그먼트, 스택 영역이 있는 세그먼트 등이 있다.

반면 프로세스 입장에서는 코드 영역, 데이터 영역, 힙 영역, 스택 영역을 서로 인접한 것처럼 바라본다.

세그멘테이션의 장점은 메모리를 가변적으로 분할할 수 있고 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 모듈로 처리할 수 있기 때문에 공유와 각 영역에 대한 메모리 접근보호가 편리하다.

단점으로는 가변 분할 방식의 단점인 외부 단편화가 발생한다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/c7685ae2-6a98-4685-bdf4-dd7ee25ef68c)

사용자와 프로세스, CPU가 바라보는 주소는 논리주소라고 한다. 실제 물리주소로 변환은 중간에서 메모리 관리자(MMU)가 해준다. 그럼 메모리 관리자는 어떻게 논리주소를 물리주소로 변환할까?

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/cedd3586-bacb-4f9b-934c-b92678c21b3d)

메모리 관리자는 세그멘테이션 테이블이라는 것을 가지고 있다. 세그멘테이션에는 Base Address와 Bound Address 정보가 저장되고 이걸 이용해 물리 메모리 주소를 계산한다. CPU에서 논리주소를 전달하면 메모리 관리자는 이 논리주소가 몇번 세그먼트인지 알아낸다. 그리고 메모리 관리자내에 Segment Table Base Register를 이용해서 물리 메모리내에 있는 세그멘테이션 테이블을 찾고 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾는다. 참고로 운영체제는 컨텍스트 스위칭을 할 때마다 Segment Table Base Register를 해당 프로세스의 것으로 값을 바꿔줘야한다. 

메모리 관리자는 CPU에서 받은 논리주소와 Bound Address 값을 비교하여 만약 논리주소가 Bound Address보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고 만약 논리주소가 다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킨다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/28df850c-25d5-4e69-a1fc-4d4247ba9774)

CPU에서 세그먼트 1번이 0x632번지로 접근한다고 가정. 메모리 관리자는 CPU의 요청을 받고 세그먼트 1번인 것을 알아낸다. 그리고 메모리 관리자내에 있는 Segment Table Base Register를 이용해서 세그멘테이션 테이블을 찾아낸다. 세그멘테이션 테이블을 찾은 다음 세그먼트 1번이 위치한 1번 인덱스를 참조한다. 논리주소 632가 Bound Address 1000보다 작으므로 논리주소 632와 Base Address 5200을 더해 물리주소 5832를 반환한다.

# 페이징(배치정책)
페이징은 메모리를 할당할 때 일정 크기의 페이지로 나눈다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/44209f47-63b8-427a-b9d7-d4d5b75b1004)

페이징에서 논리주소공간은 일정한 크기로 균일하게 나뉜다. 이것을 페이지라고 한다. 물리주소공간도 페이지의 크기와 동일하게 나뉘는데 이걸 프레임이라고 부른다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/389b07d5-16c8-4094-8077-d1cbbe29116e)

세그멘테이션과 페이징의 차이점은 페이지의 크기이다. 세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 가지고 있지만, 페이징은 모든 페이지의 크기가 동일해서 Bound Address는 필요하지 않다.  페이징은 이러한 특징 때문에 외부 단편화는 발생하지 않지만 공간이 낭비되는 내부 단편화 현상이 일어난다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/d53331d7-6106-4965-98dc-8a91b2b92945)

또 다른 차이로는 세그멘테이션은 논리적인 영역별로 세그먼트를 나눈다. 세그먼트마다 크기를 다르게 나눌 수 있으니 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 나눌 수 있다. 반면 페이징은 페이지의 크기가 고정되어 있어 논리적인 영역별로 나누는 것이 아니라  페이지로 나누기 때문에 특정영역만 따로 공유하거나 권한을 부여하는게 더 어렵다.

### 페이징의 주소 변환
![image](https://github.com/skcy1515/Programming-Study/assets/140364849/48bc15b1-e95a-4c6b-862d-88c917a42306)

세그멘테이션과 마찬가지로 메모리 관리자는 테이블을 가지고 있는데 이를 페이지 테이블이라고 부른다. CPU에서 논리주소를 전달해주면 메모리 관리자는 이 논리주소가 몇 번 페이지인지, 오프셋은 얼마인지 알아낸다. 그리고 메모리 관리자내에 Page Table Base Register를 이용해서 물리 메모리에 있는 페이지 테이블을 찾고 페이지 번호를 인덱스로 프레임 번호를 알아내고 오프셋을 이용해 물리주소로 변환한다. 오프셋은 계산을 통해 쉽게 구할 수 있다. 

페이지 테이블에 Invalid로 표시되어 있으면 스왑 영역 즉, 하드디스크에 저장되어 있다는 의미이다. 세그멘테이션과 마찬가지로 Page Table Base Register는 운영체제가 컨텍스트 스위칭을 할 때마다 해당 프로세스의 것으로 업데이트 해준다.

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/ee7560ff-b950-4a0d-9a44-e052c99512ce)

32bit CPU의 주소변환 예시

논리주소공간(4GB)를 16MB의 페이지 256개로 나눈다. 물리주소의 프레임도 가상주소의 페이지의 크기와 동일한 16MB로 나눈다. 메모리 관리자내에 페이지 테이블은 1차원 배열로 구성되어있는데 페이지 번호가 배열의 인덱스가 된다. 여기서 CPU가 논리주소 0x1000번지에 접근한다고 가정한다.

- 페이지 넘버 = 논리주소 / 페이지 크기, 1000번지의 페이지 넘버는 0 (1000 / 16777216)
- 오프셋 = 논리주소 % 페이지 크기 1000번지의 오프셋은 1000

페이지 넘버를 인덱스로 참조하여 프레임을 가져오는데, 0번 인덱스의 프레임이 3이니 3번 위치에서 오프셋 1000만큼 더해주면 물리주소가 나온다.

# 페이지드 세그멘테이션
메모리 접근 권한: 메모리의 특정 번지에 부여된 권한으로 읽기, 쓰기, 실행 세 가지가 있다. 프로세스는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있는데 각 영역마다 접근 권한이 있다.
- 코드 영역: 읽기, 실행 권한
- 데이터 영역: 읽기, (쓰기) 권한
- 힙, 스택 영역: 읽기, 쓰기 권한

![image](https://github.com/skcy1515/Programming-Study/assets/140364849/df011608-5b30-4978-898a-51359eeeec27)

가상주소가 들어오면 먼저 가상주소를 이용해 몇 번 세그먼트인지 알아낸다. 그리고 권한비트를 통해 해당 세그먼트가 메모리 접근 권한을 위반하는지 검사한다. 접근 권한을 위반했으면 프로세스를 종료시키고 위반하지 않으면 페이지 넘버와 페이지 개수를 가져온다. 

그리고 페이지 넘버로 페이지 테이블에 접근해서 프레임 번호를 가져오고 물리 메모리내에 해당 프레임에 접근해서 그 위치에서 페이지 개수를 더해 물리주소를 구한다.

페이지드 세그멘테이션의 단점은 물리메모리에 접근하기 위해서 메모리에 접근을 두 번 해야된다는 것이다. 첫 번째는 세그멘테이션 테이블을 참조할 때, 두 번째는 페이지 테이블을 참조할 때이다.
